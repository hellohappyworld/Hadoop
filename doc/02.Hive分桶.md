#### 						Hive分桶

```
#首先创建一个分桶表
create table if not exists buc2(
uid int,
uname string,
age int
)
clustered by (uid) into 4 buckets
row format delimited fields terminated by ','
;
#加载数据到分桶表：(load方式加载数据不能体现分桶)
bucket1.txt内数据
1,p1,12
2,p2,11
3,p3,33
4,p4,22
5,p5,23
6,p6,23
7,p7,90
8,p8,12
9,p9,34

load data local inpath '/home/hadoop/testData/bucket1.txt'
into table buc2;
#设置强制分桶属性
set hive.enforce.bucketing;//查看当前状态
set hive.enforce.bucketing=true;//原始为false
set mapreduce.job.reduces=4;//如果设置了reduces的个数，在执行分桶之前，最好是将reduces的数量设置成分桶的数量。
#创建临时表
create table if not exists buc_temp(
uid int,
uname string,
age int
)
row format delimited fields terminated by ','
;
#加载数据
load data local inpath '/home/hadoop/testData/bucket1.txt'
into table buc_temp;
#使用insert into的方式加载数据到分桶表(这种方式能体现分桶)
insert overwrite table buc2
select uid,uname,age from buc_temp
cluster by(uid)
;
hive> select * from buc2;
OK
4	p4	22
8	p8	12
---------------第一个桶，id:0
1	p1	12
5	p5	23
9	p9	34
---------------第二个桶，id:1
2	p2	11
6	p6	23
---------------第三个桶，id:2
3	p3	33
7	p7	90
---------------第四个桶，id:3

#查询桶的数据
select *from buc2 tablesample(bucket 1 out of 4 on uid);
4	p4	22
8	p8	12

#创建分桶表，指定排序字段已经排序规则（指定的排序是设计者预期的一种排序结果）
create table if not exists buc3(
uid int,
uname string,
age int
)
clustered by (uid)
sorted by (uid desc) into 4 buckets
row format delimited fields terminated by ','
;
#加载数据
insert overwrite table buc3
select uid,uname,age from buc_temp
distribute by (uid) sort by (uid asc);
#查询全部
hive> select * from buc3;
4	p4	22
8	p8	12
1	p1	12
5	p5	23
9	p9	34
2	p2	11
6	p6	23
3	p3	33
7	p7	90
select * from buc3 tablesample(bucket 1 out of 1);
4	p4	22
8	p8	12
1	p1	12
5	p5	23
9	p9	34
2	p2	11
6	p6	23
3	p3	33
7	p7	90
#查询第几桶
select * from buc3 tablesample(bucket 1 out of 4 on uid);//查询的是第一桶的数据
4	p4	22
8	p8	12
select * from buc3 tablesample(bucket 1 out of 2 on uid);//查询的是第1桶和第3桶的数据
4	p4	22
8	p8	12
2	p2	11
6	p6	23
select * from buc3 tablesample(bucket 1 out of 8 on uid);//查询的是第1桶内的第二条数据
8	p8	12

#抽样查询：tablesample(bucket x out of y)
x:代表从第几桶开始查询
y：查询到总桶数，y可以是总桶数的因子或者倍数。x不能大于y
计算方法：
例如本表buc3总共分了4个桶，tablesample(bucket 1 out of 2 on uid)表示总共抽取4/2=2个桶的数据，分别为第1个桶和第1+2=3个桶的数据；
又如：tablesample(bucket 1 out of 8 on uid)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

#查询id为奇数
select * from buc3 tablesample(bucket 2 out of 2 on uid);//查询id=1,3的桶的数据，也就是第二，四个桶的数据
1	p1	12
5	p5	23
9	p9	34
3	p3	33
7	p7	90
#查询id为奇数以及uname=p9
select * from buc3 tablesample(bucket 2 out of 2 on uid)
where uname='p9';
9	p9	34
#查询前3行数据
select * from buc_temp limit 3;
1	p1	12
2	p2	11
3	p3	33
select * from buc_temp tablesample(3 rows);
1	p1	12
2	p2	11
3	p3	33
select * from buc_temp tablesample(7B);//一个字符为1B,空格也为1B
1	p1	12
select * from buc_temp tablesample(33.33333 percent);//一共有9行数据，所以前3行占所有的33.333333%
1	p1	12
2	p2	11
3	p3	33
#hive的本地执行模式设置（可以提高sql运行速度）
set hive.exec.mode.local.auto=false/true;

##################分桶总结####################
1.定义
clustered by(uid)---指定分桶字段
sorted by (uid desc)---指定数据的排序字段(desc为倒序，asc为升序)
2.导数据
cluster by(uid)---指定gertPartition以哪个字段进行hash，并且排序字段也是这个指定的字段，排序字段默认以顺序排序
distribute by(uid)---指定getPartition以哪个字段进行排序
导入数据时：
insert overwrite table buc3
select uid,uname,age from buc_temp
cluster by(uid);
和
insert overwrite table buc3
select uid,uname,age from buc_temp
distribute by(uid) sort by (uname asc);//这种方式可以分别指定getpartition的字段和sort字段.
这两种结果是一样的.
```



